# learn-javascript

- Hoisting
    
    모든 변수 선언문이 코드의 최상단으로 이동되는 것’처럼’ 느껴지는 현상
    
    - var의 경우 선언과 동시에 undefined로 초기화되기 때문에 값을 할당하기 전에 접근 가능
    - let과 const의 경우 호이스팅이 발생하지만 값이 할당되기 전까지 접근 불가능
- Memory
    
    프로그래밍을 할 때 가장 중요한 컴퓨터의 하드웨어 요소
    
    CPU - 연산, 메모리 - 저장
    
    메모리 셀 : 메모리가 구성된 단위, 1 바이트의 크기, 각각의 주소를 가짐, 16진수로 표현
    
    let calc = 2 + 5인 경우
    
    1. 메모리에서 2와 5를 가져옴
    2. CPU에서 연산하여 7의 결과를 얻음
    3. 메모리 내 새로운 공간에 저장
    - 하지만 메모리에 직접적으로 접근한다면 큰 문제가 생길 수 있음 (시스템 파일 삭제 등)
    - 따라서 주소를 참조하는 변수를 통해 접근하게 하여 직접적인 접근을 방지
    
- Copy by Value vs. Copy by Reference
    - Copy by Value
        1. original 변수를 메모리 공간에 할당
        2. clone이라는 변수를 새로운 메모리 주소로 할당
        3. clone의 주소의 값을 변경
        
        ⇒ clone을 변경해도 original의 주소에 접근하지 않아 원본 값이 변경되지 않음
        
    - Copy by Reference
        1. 실제 객체를 메모리 공간에 할당
        2. originalObj는 실제 객체를 가리키는 주소 값을 가짐
        3. cloneObj는 originalObj가 가지고 있는 주소 값을 복사함
        4. 실제 객체 변경 시, originalObj와 cloneObj가 가리키는 객체가 동시에 변경됨
        
- Class
    
    클래스 : 객체지향 프로그래밍에서 특정 객체(인스턴스)를 생성하기 위한 변수와 메소드(함수)를 정의하는 일종의 틀
    
    ⇒ 정보를 일반화해서 정리하는 방법
    
- Inheritance
    
    상속 : 객체들 간의 관계를 구축하는 방법, 부모(슈퍼) 클래스 등의 기존의 클래스로부터 자식 클래스가 속성과 동작을 상속받을 수 있음
    
- Prototype
    
    new 키워드로 함수의 객체를 생성할 때는 실제 함수의 프로토타입 값이 __proto__에 삽입되며, 상속 체인의 바로 위 역할을 함
    
    함수의 __proto__ → Function.prototype 
    
    Function.prototype.__proto__ → Object.prototype
    
    ⇒ 상속 체인의 가장 최상위에는 Object.prototype이 존재
    
    Prototype을 통해 인스턴스 간 공유하는 메소드를 한 곳에 정의하여 메모리 효율을 높일 수 있음
    
- Scope
    
    함수를 실행할 때, 함수 밖에 있는 변수에 접근 가능
    
    모든 선언은 가장 가까운 스코프의 선언을 사용
    
- Execution Context(실행 컨텍스트)
    
    실행 컨텍스트 : 실행하려는 JS 코드와 코드를 실행할 때 필요한 정보를 담고 있는 특수한 환경
    
    ⇒ 코드 실행에 필요한 모든 데이터를 들고 있는 환경
    
    실행 컨텍스트의 종류
    
    - Global Context(전역 실행 컨텍스트) : 최상위 실행 컨텍스트, 코드를 실행하면 무조건 생성되는 실행 컨텍스트로, 웹에서의 window, nodeJS에서의 global 객체를 생성하고 들고 있음
    - Function Context(함수 실행 컨텍스트) : 함수가 실행될 때마다 함수 별로 실행되는 컨텍스트, 함수 실행에 대한 모든 정보를 가지고 있음
    
    자바스크립트는 싱글 스레드 언어 → 하나의 메모리 힙과 콜 스택(실행 컨텍스트 스택) 존재
    
    실행 컨텍스트의 단계
    
    1. Creation Phase(생성 단계) : Global Object를 생성, window 또는 global 객체가 생성되고 함수에서는 arguments 객체가 생성, this를 window 또는 global에 바인딩, 변수와 함수를 Memory Heap에 배정하고 기본 값을 undefined로 저장
    2. Execution Phase(실행 단계) : 코드를 실행, 필요하다면 새로운 실행 컨텍스트를 생성
    
    ⇒ 생성 단계가 실행되고 나서 실행 단계가 실행되기 때문에 변수와 함수가 먼저 메모리 힙에 undefined로 저장되는 호이스팅이 발생
    
- Closure
    
    상위 함수에서 하위 함수를 반환할 때, 상위 함수가 먼저 실행이 끝나고 하위 함수를 나중에 실행할 수 있는 기능
    
    렉시컬 스코프 룰에 의해 선언할 때의 위치가 상위 스코프를 정하기 때문에 선언 시의 변수 사용 가능
    
- Async Programming
    
    스레드 : 가장 작은 작업 단위 (예를 들어, 16스레드 ⇒ 동시에 16개의 작업까지 할 수 있음)
    
    Javascript는 싱글 스레드이기 때문에 어느 한 순간에 동시에 단 하나의 작업만 실행할 수 있음 ⇒ 싱글 스레드의 단점을 비동기 프로그래밍으로 극복
    
    Sync Programming (동기 프로그래밍) : 오래 걸리는 작업이 마무리 될 때까지 대기하고 작업을 순서대로 처리
    
    Event Loop : 비동기 작업이 콜 스택에 들어오면 태스크 큐로 보내서 처리 → 태스크 큐를 바라보며 실행이 종료된 함수가 있는지 확인, 콜 스택이 비어 있는지 확인 → 콜 스택이 비어 있을 경우, 태스크 큐에서 종료된 함수를 콜 스택으로 옮김
    
- Callback
    
    콜백 함수 : 특정 작업 이후에 다시 불리는 함수
